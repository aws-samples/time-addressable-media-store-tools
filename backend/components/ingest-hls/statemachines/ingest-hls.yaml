QueryLanguage: JSONata
StartAt: ParseManifest
States:
  ParseManifest:
    Type: Task
    Resource: arn:aws:states:::lambda:invoke
    Arguments:
      FunctionName: ${VariantFunctionArn}
      Payload: >-
        {% $states.input %}
    Assign:
      flowManifests: >-
        {% $states.result.Payload.flowManifests %}
      flows: >-
        {% $states.result.Payload.flows %}
      multiFlows: >-
        {% $states.result.Payload.multiFlows %}
    Retry:
      - ErrorEquals:
          - NoSuchKey
          - HTTPError
        IntervalSeconds: 10
        MaxAttempts: 30
        BackoffRate: 1.0
    Output: null
    Next: CreateFlows
  CreateFlows:
    Type: Map
    Items: >-
      {% $flows %}
    Assign:
      flows: null
    ItemProcessor:
      ProcessorConfig:
        Mode: INLINE
      StartAt: PutFlow
      States:
        PutFlow:
          Type: Task
          Resource: arn:aws:states:::http:invoke
          Arguments:
            Method: PUT
            InvocationConfig:
              ConnectionArn: ${ConnectionArn}
            ApiEndpoint: >-
              {% '${TamsEndpoint}/flows/' & $states.input.id %}
            Headers:
              Content-Type: application/json
            RequestBody: >-
              {% $states.input %}
          Retry:
            - ErrorEquals:
                - Events.ConnectionResource.InvalidConnectionState
                - Events.ConnectionResource.AuthInProgress
                - Events.ConnectionResource.ConcurrentModification
              IntervalSeconds: 1
              BackoffRate: 2
              MaxAttempts: 3
          End: True
    Output: null
    Next: CreateMultiFlows
  CreateMultiFlows:
    Type: Map
    Items: >-
      {% $multiFlows %}
    Assign:
      multiFlows: null
    ItemProcessor:
      ProcessorConfig:
        Mode: INLINE
      StartAt: PutMultiFlow
      States:
        PutMultiFlow:
          Type: Task
          Resource: arn:aws:states:::http:invoke
          Arguments:
            Method: PUT
            InvocationConfig:
              ConnectionArn: ${ConnectionArn}
            ApiEndpoint: >-
              {% '${TamsEndpoint}/flows/' & $states.input.id %}
            Headers:
              Content-Type: application/json
            RequestBody: >-
              {% $states.input %}
          Retry:
            - ErrorEquals:
                - Events.ConnectionResource.InvalidConnectionState
                - Events.ConnectionResource.AuthInProgress
                - Events.ConnectionResource.ConcurrentModification
              IntervalSeconds: 1
              BackoffRate: 2
              MaxAttempts: 3
          End: True
    Output: null
    Next: ProcessMediaManifests
  ProcessMediaManifests:
    Type: Map
    Label: ProcessMediaManifests
    MaxConcurrency: 1000
    Items: >-
      {% $flowManifests %}
    Assign:
      flowManifests: null
    ItemProcessor:
      ProcessorConfig:
        Mode: DISTRIBUTED
        ExecutionType: STANDARD
      StartAt: ProcessManifest
      States:
        ProcessManifest:
          Type: Task
          Resource: arn:aws:states:::lambda:invoke
          Arguments:
            FunctionName: ${MediaFunctionArn}
            Payload: >-
              {% $states.input %}
          Output: >-
            {% $states.result.Payload %}
          Next: ProcessSegments
        ProcessSegments:
          Type: Map
          Label: ProcessSegments
          MaxConcurrency: 1000
          ItemBatcher:
            MaxItemsPerBatch: 10
          Items: >-
            {% $states.input.segments %}
          ItemProcessor:
            ProcessorConfig:
              Mode: DISTRIBUTED
              ExecutionType: STANDARD
            StartAt: ProcessSegment
            States:
              ProcessSegment:
                Type: Task
                Resource: arn:aws:states:::lambda:invoke
                Arguments:
                  FunctionName: ${SegmentFunctionArn}
                  Payload: >-
                    {% $states.input %}
                Output: null
                End: True
          Output: null
          Next: CheckManifestLocation
        CheckManifestLocation:
          Type: Choice
          Default: ExtXEndlist
          Choices:
            - Next: WaitTargetDuration
              Condition: >-
                {% $exists($states.input.targetDuration) %}
              Output: >-
                {% $states.input %}
        WaitTargetDuration:
          Type: Wait
          Seconds: >-
            {% $states.input.targetDuration %}
          Output: >-
            {% $states.input %}
          Next: ProcessManifest
        ExtXEndlist:
          Type: Succeed
    Output: null
    End: True
